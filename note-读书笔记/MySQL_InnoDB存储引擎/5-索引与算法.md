# 5. 索引与算法

## B+树索引

B+树是为磁盘设计的一种平衡查找树。所有的记录节点都是按照键值的大小顺序放在同一层的叶子节点上，由各叶子节点直接进行连接。

<figure>
  <img src="mysql_innodb.assets/image-20210906163411709.png" alt="img" style="zoom: 50%;">
  <figcaption>Fig.5-1 2层的B+树。</figcaption>
</figure>



B+树在数据库中具有高扇出性，高度一般在2-4层。

数据库中的索引可以分为聚集索引和辅助索引，二者内部数据结构都是高度平衡的B+树。

### 聚集索引clustered index

聚集索引的B+树的叶子节点存放的是键值（主键 ID）以及指向**数据页的偏移量**。

而数据页上存放的是完整的、每行的记录。

<figure>
  <img src="mysql_innodb.assets/image-20210906164656536.png" alt="img" style="zoom: 50%;">
  <figcaption>Fig.5-2 B+树索引。</figcaption>
</figure>

### 辅助索引secondary index

辅助索引的叶子节点除了包含键值以外，还包含了指向相应行数据的聚集索引键。

当通过辅助索引查询数据的时候，引擎首先根据辅助索引叶子节点的数据获得指向主键索引的主键，然后再通过主键索引获取对应的行记录。

> 这里获取到主键是指获取到主键的值，而非主键的指针。
>
> 因此可能的一个查询过程：辅助索引三次查找获得主键值，主键索引再三次查找获取行记录。
>
> 先通过辅助索引获取主键索引，再通过主键索引获取行记录的查询过程，称之为回表。

## Cardinality

> 如何评估一个索引建的好不好？
>
> 比如按照性别建立索引，那么男女的表中记录可能各占50%，这种索引就没有意义；
>
> 可见，索引应该和其下的记录数量有关，最好就是一个键值对应一条数据，这被称之为可选择性。

如何查看索引是否具有高选择性？

`show index` 的结果中会给出 cardinality 的数值，表示不重复的记录的数量的预估值。

`cardinality` 与 `n_rows_in_table` 的值应该尽量接近于1。（比如主键这个比值应该非常接近于1）

## B+树索引的使用

### 联合索引 joint index

多个列构成一个索引，如果idx_a_b。B+树首先根据列a的值进行排序，a值相同的情况下，再按照b值进行排列。

idx_a_b对于

`select * from t where a = xxx and b = xx` 这种查询语句特别高效，或者

`select * from t where a = xxx order by b desc` a值固定，查询语句需要根据b排序。

但是并不能加快b的查询。

```mysql
# idx_a_b就是联合索引。
create table t (
  a int,
  b int,
  primary key (a),
  key idx_a_b (a,b)
) ENGINE = InnoDB
```

### 覆盖索引 covering index

这种指的是从辅助索引中就可以得到查询的值。

辅助索引的叶子节点包含了主键索引的信息，比如（primary key1, primary key2, key3, key4...)

也就是说查询的值被叶子节点cover了，这样就不需要再通过主键索引访问行记录。

### 优化器不使用索引

查询语句的查询条件和某个辅助索引有关，但是最终却选择了全表扫描。

这是因为没有命中覆盖索引，辅助索引需要通过主键键值访问数据，代价过高。

```mysql
# 如果order_id范围内的数据占全表的20%以上，则可能进行全表扫描。
select * from t where order_id > 100 and order_id < 1000;
```

