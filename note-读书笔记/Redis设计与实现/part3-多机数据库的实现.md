> Redis 中可以使用 *SLAVEOF* 选项，让一个服务器去复制（replicate）另一个服务器。

# 1 - 复制（replicate）

如果希望主从服务器的数据保持一致，也就是从服务能跟上主服务的变化，那么需要有一个 track 的机制。

复制功能实现经过了迭代，新版的复制功能效率更高。

## 1.1 旧版复制功能的实现

Redis  的复制功能分为**同步**（sync）和**命令传播**（command propagate）两个操作。

### 同步

同步操作就是将从服务器更新至主服务当前所处的数据库状态。具体的实现是通过 **传递RDB 文件 **实现的。

当从服务向主服务发送 *SYNC* 命令时：

1）收到 *SYNC* 命令的主服务执行 *BGSAVE* 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令。

2）当 *BGSAVE* 命令执行完毕时，RDB 文件将会通过网络从主服务器传递到从服务器；

3）从服务器接收并且载入这个 RDB 文件，将自身数据库状态更新至主服务执行 *BGSAVE* 时的状态。

4）从服务器消化 RDB 文件后，主服务器再将缓冲区中的写命令传递给从服务器。

### 命令传播

通过上述的同步操作，主从服务器两者的数据库状态将达到一致的状态。

但是这种一致状态随着主服务接收写命令后，很快就会被破坏。

因此，主服务器需要将写命令传递给从服务器，这被称之为命令传播。

<figure>
  <img src=Redis设计与实现.assets/image-20211003155722208.png alt="img" style="zoom:100%;">
  <figcaption>Fig. 1.1 主从服务器执行 SYNC 的过程，之后只需要进行命令传播。</figcaption>
</figure>

## 1.2 新版复制功能的实现

在 Redis 中，复制可能发生在一下两种情况：

1）**初次复制**：也就是从服务器首次复制主服务器。

2）**断线后重新复制**：在命令传播阶段，主从断开了连接，重连时需要重新复制。

旧版复制功能能够很好的完成任务。但是断线后重新复制，如果再次执行完整的同步 + 命令传播两个步骤，则效率十分低下。

> *SYNC* 是一个十分消耗资源的功能。
>
> 1）主服务器需要消耗大量的 CPU、内存和磁盘 I/O 资源生成 RDB 文件；
>
> 2）RDB 文件传输过程中需要消耗大量网络带宽；
>
> 3）从服务器消费 RDB 文件时处于阻塞状态，无法处理命令请求。

对于断线后重新复制，实际上只需要将断线期间的数据变化传递给从服务器，从服务就能及时跟上。

**部分重同步** *PSYN* 根据复制的两种情景决定全部还是部分复制。如果是初次复制，则需要全部复制，否则只需要执行部分复制。

如果是部分复制的话，*PSYNC* 如何确定开始复制的位置？复制偏移量！

1）**复制偏移量**（replication offset)

​	复制的双方分别维护一个偏移量，主服务每次向从服务传递 N 个字节的数据时，就将自身复制偏移量加上 N；从服务接收到主服务器传播来的 N 个字节的数据，也会将复制偏移量加上 N。

​	通过对比主从服务器的复制偏移量，从服务能很快确定复制的起点。从服务器需要从主服务器中获得滞后的数据，这意味着主服务器需要维护一个复制缓冲区。

2）**复制积压缓冲区** 

​	复制积压缓冲区是一个固定长度的 FIFO 队列，默认大小为 1MB。命令传播时，主服务器除了将命令发送给所有从服务器，还会将写命令写入到复制积压缓冲区。

​	但是毕竟复制积压缓冲区容量有限，如果数据已经不存在于该区域，则需要执行完整的复制动作。

3）**服务器运行 ID**

​	如何判定从服务器是否复制过当前服务器的数据？

​	从服务器会记录一个主服务器运行 ID，首次同步时主服务器会将自己的运行 ID 发送给从服务器；当从服务器断线重连时，从服务器需要向主服务发送运行 ID，作为全部/部分复制的参考。

<figure>
  <img src=Redis设计与实现.assets/image-20211003160015518.png alt="img" style="zoom:100%;">
  <figcaption>Fig. 1.2 *PSYNC* 判断执行完整或者完整重同步。</figcaption>
</figure>



## 1.3 心跳检测

在命令传播阶段，从服务器默认每隔 1 秒向从服务器发送命令：*REPLCONF ACK <replication_offset>*

确认当前偏移量的目的有三个：

1）检测主从服务器的网络连接状态；

2）复制实现 `min-slaves ` 选项；

3）检测命令丢失；



## 重点回顾

* Redis  2.8 以前的复制功能不能高效处理断线重连后重新复制的情况，2.8 之后的版本新添加的部分重同步可以解决这个问题；
* 部分重同步通过复制偏移量、复制积压缓冲区和服务器 ID 三个部分实现；
* 主服务器通过命令传播来更新从服务器的状态，保持主从服务一致；
* 从服务器通过向主服务器发送命令来进行心跳检测和命令丢失检测。



# 2 - 哨兵 （sentinel）

Sentinel 是 Redis 高可用的解决方案：

1）由一个或者多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器。

2）当被监视的主服务器进入下线状态时，主动将下线主服务器下属的某个从服务器升级为新的主服务器；

<figure>
  <img src=Redis设计与实现.assets/image-20211003170623623.png alt="img" style="zoom:100%;">
  <figcaption>Fig. 2.0 服务器与 Sentinel 系统。 Sentinel  负责监督主从服务器，如果主服务器下线，则挑选某个下述服务器升级成为主服务器。</figcaption>
</figure>
## 重点总结

1）Sentinel 本质是一个特殊的 Redis 服务器

Sentinel 只是一个运行在特殊模式下的 Redis 服务器，它使用了和普通模式不同的命令表，所以 Sentinel 模式能够使用的命令和普通 Redis 服务器能够使用的命令不同；

2）Sentinel 获取监听的主服务器

Sentinel 会读入用户配置文件，为每个需要监听的主服务器创建相应的实例结构，并与主服务器创建命令连接和订阅连接。

* **命令连接**：用于向主服务器发送连接请求；
* **订阅连接**：`__sentinel__:hello`    用于接收指定频道的消息。

3）Sentinel 获取监听主服务器下属的从服务器

Sentinel 通过向主服务器发送 *INFO* 命令获取下属的所有从服务器的地址；Sentinel 同样会对从服务器创建相应的实例结构以及建立命令连接和订阅连接。

4）Sentinel 定期获取主服务器运行状态

一般情况下，Sentinel 每隔 10s 向被监视的主从服务器发送 *INFO* 命令；如果主服务处于下线状态，或者 Sentinel 正在进行故障转移操作时频率会提高到每秒一次。

5）Sentinel 系统 sentinel 之间互相通信

监视同一个主服务器和从服务器的 sentinels 每隔 2s 会向服务器的 `__sentinel__:hello`频道发送消息，以告知其他 sentinels 自身的存在。每个 sentinel 从订阅频道接收来自其他 sentinel 的消息，并创建相应的实例结构和命令连接（不需要创建订阅连接）。

6）Sentinel 感知和判定实例是否下线

这里的实例包括主服务器、从服务器和其他的 sentinels。

sentinel 每隔 1s 向实例发送 *PING* 命令，然后根据回复判断实例是否在线：如果在指定时长连续收到无效回复时，则判定为**主观下线**。

7）实例的客观下线

当一个实例被一个 sentinel 判定为主观下线时 ，sentinel 会询问同样监视这个主服务器的其他 sentinels；当收集到足够多的主观下线投票后，实例被认定为客观下线，并发起一次针对主服务器的故障转移操作。

8）**故障转移**

当一个主服务器被判定为客观下线时，监视这个下线主服务器的各个 sentinel 会进行协商，选举出一个领头 sentinel，并由这个领头 sentinel 对下线主服务器进行故障转移操作：

1）选出新的主服务器：在客观下线的主服务器的下属从服务器中选出一个状态良好、数据完整的从服务器作为主服务器；

2）让下线主服务器的其他从服务改为复制新的主服务器；

3）将已下线的老的主服务器设置为新的主服务的从服务器；如果这个旧主服务器重新上线，将会成为新的主服务器的从服务。



# 3 - 集群

Redis 集群是 Redis 提供的数据方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。

这里主要进行概念的介绍：节点、槽指派、命令执行、重新分片、转向、故障转移、消息等。

## 3.1 节点

一个 Redis 集群是有多个节点（node）组成。

通过 `CLUSTER MEET` 可以将各个独立的节点连接起来，构成一个包含多个节点的集群。

Redis 服务启动时会根据配置中的 `cluster-enable` 选项来决定是否开启服务器的集群模式：

* 为 `yes` 的话，则开启服务器的集群模式，成为一个节点
* 否则，开启服务器的单机模式（stand alone）模式，成为一个普通 Redis 服务器。

<figure>
  <img src=Redis设计与实现.assets/image-20211003202544079.png alt="img" style="zoom:100%;">
  <figcaption>Fig. 3.1 节点的握手过程。节点 A 会通过 Gossip 协议将 B 介绍给集群中的其他节点，让他们也和 B 握手。</figcaption>
</figure>

## 3.2 槽指派

Redis 集群通过分片的方式来保存集群中的 K-V 数据：

1）集群中的整个数据库被划分为 16384 个槽（slot）；

2）键值对通过某种方式映射到槽位上；

3）每个节点负责一定数目的槽位，0 个或者16384个。

如果有任一一个槽位没有被集群中的节点认领，则认为集群处于**下线状态（fail）**；反之，处于**上线状态（ok）**。

因此，一个集群中的所有节点会互相记录和传播负责的槽位范围，每个节点都清楚 16384 个槽位分别由谁负责。

每个槽位都被指派清楚后，集群就可以上线了。

## 3.3 在集群中执行命令

执行过程如下：

1）客户端向集群中的某个节点发送命令请求；

2）节点计算出命令涉及到的键属于哪个槽位：`slot = CRC16(key) % 16384`。

3）如果槽位刚好在自身节点，则执行命令；否则返回  `MOVED` 错误。

4）客户端如果接收到 `MOVED` 错误，则会自动重试；

<figure>
  <img src=Redis设计与实现.assets/image-20211003204015018.png alt="img" style="zoom:50%;">
  <figcaption>Fig. 3.3 集群处理客户端请求过程。如果请求到了错误的节点，需要重定向。</figcaption>
</figure>



> `MOVED`  错误格式为 `MOVED <slot> <ip> :<port>`;
>
> 该错误对用户透明，客户端隐藏这个错误并且自动转向。

## 3.4 重新分片

经过槽指派后，Redis 集群仍然可以重新分配每个节点负责的槽位范围，这个过程称之为槽分片。

重新分片可以在线执行，执行过程中集群不需要下线，源节点和目标节点仍然可以正常处理请求。

分片结束后，槽位范围被重新规划，对应的数据也会被搬迁。

重新分片由 Redis 集群管理软件 redis-trib 负责，通过向源节点和目标节点发送命令来实现。

## 3.5 ASK 错误

如果客户端请求正在重新分片的源节点，并且相关的键恰好位于正在搬迁的槽位，那么就需要分类讨论了：

1）源节点发现请求的键还在自身节点上，那么执行命令返回；

2）请求键不在自身节点上，那么有可能存在于目标节点，于是源节点返回 ASK 错误，引导客户端访问目标节点。

<figure>
  <img src=Redis设计与实现.assets/image-20211003210122610.png alt="img" style="zoom:67%;">
  <figcaption>Fig. 3.5 重新分片可能会引发 ASK 错误。</figcaption>
</figure>



> `ASK` 错误和`MOVED` 的格式和行为类似，都建议客户端重新请求（前者临时建议重定向，后者永久重定向）。
>
> 二者的区别也是很明显的，后者节点根本不负责键对应的槽位。

## 3.6 复制与故障转移

Redis 集群中节点分为主节点和从节点：主节点用于处理槽；从节点复制主节点的数据，当主节点下线时，从节点将顶替主节点继续处理命令请求。

### 故障检测

节点之间定期 *PING-PONG*，如果某个节点疑似下线，就会发起投票；

如果半数以上的主节点认为疑似下线，则主节点将会被标记为下线` FAIL`。

### 故障转移

从节点开始对下线节点进行故障转移，从节点成为新的主节点，顶替老节点：老的节点被分配的槽位被指派给新节点，新节点处理命令请求。

## 重点回顾

1）节点通过握手，将其他节点加入到自身所在的集群；

2）集群将 16384 个槽位分配给各个节点，每个节点都清楚自身和其他节点被分配的槽位范围；

3）`MOVED` 错误发生在客户端请求的键对应的槽位不在节点上，节点返回给错误，指导客户端重新请求；

4）槽位可以重新分配，交由 `redis-trib` 工具负责。

5）`ASK` 错误产生于槽位重分配的过程中，源节点建议客户端去目标节点确定键的位置；

6）集群中的从节点复制主节点，当主节点下线时，顶替主节点处理请求。

7）集群中的节点相互通信：*PING*、*PONG*、*PUBLUSH* 和 *FAIL* 。

