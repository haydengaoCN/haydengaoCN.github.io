# 1 - RDB 持久化

Redis 是内存数据库，它将自己的数据库状态（服务器中的非空数据库以及它们的键值对）存储在内存中。

一旦服务退出，服务器中的数据库状态将消失不见。

Redis 提供了 RDB 持久化功能，这个功能可以将数据库状态持久化到磁盘的二进制文件中。

RDB 全称是 Redis Database Backup file，Redis 数据库备份文件，也被称之为 Redis 数据快照。

RDB 持久化功能所生成的文件 RDB 文件是一个经过压缩的**二进制文件**，通过该文件，Redis 可以还原成生成这个文件的时间点上的数据库状态。

## 1.1 RDB 文件的创建 *SAVE* 和 *BGSAVE*

*SAVE* 和 *BGSAVE* 都可以生成 RDB 文件。

*SAVE* 命令会阻塞 Redis 服务器进程，阻塞期间，服务器不能处理任何命令，直到 RDB 文件创建完毕。

*BGSAVE* 会 fork 出子进程用于 RDB 文件的生成，而服务器进程（子进程）可以正常处理请求。

两个命令底层都是调用 `rdbSave` 函数实现的，区别在于执行命令的进程不同。

 *BGSAVE* 执行期间，服务器能处理其他持久化请求嘛？

持久化动作设计大量的磁盘操作，所以不建议同时执行一个以上的持久化动作。

* *SAVE* ？

  为了避免两个命令同时调用 `rdbsave` 产生竞争条件，*BGSAVE* 执行期间，*SAVE* 命令会被拒绝。

* 再来一个 *BGSAVE* ？

  *BGSAVE* 执行期间，不能再执行 *BGSAVE*，同样是为了避免竞争。

* *BGREWRITEAOF* ？

  *BGSAVE* 执行期间，*BGREWRITEAOF* 会被延迟到前者持久化完成后；

  *BGREWRITEAOF* 执行期间，会拒绝 *BGSAVE* 命令。

  > 二者其实都是在子进程上执行的，所有不会有竞争关系。不能同时执行是处于性能考虑。
  >
  > 这里作者对不能同时持久化的原因阐释不是很清晰，总之是为了性能考虑。

## 1.2 RDB 文件载入

当 Redis 启动时会自动检测 RDB 文件，如果存在，会自动加载。

在载入 RDB 文件期间，服务器会一直处于阻塞状态。

因为 AOF 文件通常比 RDB 更新频率高，所以如果开启了 AOF 功能，Redis 启动时会选择 AOF 文件加载。

## 1.3 自动间隔性保存

Redis 允许用户设置一定的保存条件，条件满足时自动执行 *BGSAVE* 持久化。

比如 900 秒内，对数据库至少进行了一次修改，就执行 *BGSAVE* 命令。

```text
# 数据库默认保存条件
save 900 1
save 300 10
save 60 10000
```

```c
struct redisServer {
  redisDb *db;  // 数据库数据，保存服务器中的所有数据库；
  int dbnum;  // 服务器的数据库数目，默认有16个；
  
  struct saveparams *saveparams;  // 保存条件
  long long dirty;  // 服务器修改计数器
  time_t last_save;  // 上一次执行保存的时间
};
```

Redis  的服务器周期性操作函数 `saveCron` 定期检查保存条件（每个 100ms 执行一次）。

## 1.4 RDB 文件结构与分析

Redis 本身自带 RDB 文件检查工具 *redis-check-dump*，帮助分析 二进制 RDB 快照数据。

## 1.5 重点总结

* RDB 文件用户保存和恢复 Redis 服务器中的所有键值对；
* *SAVE* 命令由服务器进程直接执行，因此会阻塞服务器；
* *BGSAVE* 命令是由服务器进程 fork 出的子进程执行的，因而不会阻塞服务器；
* 可以设置保存条件，满足时服务器自动执行 *BGSAVE*；
* RDB 文件是经过压缩的二进制文件，由多个部分组成；
* RDB 文件会用不同的方式保存不同的键值对；



# 2 - AOF 持久化

AOF （append only file）通过保存 Redis 服务器所执行的写命令来记录数据库状态。

Redis 服务启动时，通过载入和执行 AOF 文件中保存的命令，可以还原服务器关闭之前的数据库状态。

AOF 是纯文本格式，保存的是 Redis 的命令请求协议。

> 纯文本的意思是 human-readble，可以直接打开并观察文件内容。



## 2.1 AOF 持久化的实现

当服务器执行完成一个写入命令的时候，会将该命令（以一定的协议格式）追加到服务器状态的 `aof_buf` 缓冲区的末尾。

为了真正实现持久化，需要将 `aof_buf` 的数据落实到磁盘中的 AOF 中，而这个过程分为两步：写入（write）和同步（sync）。

> 为了提高文件的写入效率，现在操作系统中，当用户调用 write 函数时，并非直接写入到磁盘中，过程应该是：
>
> 用户空间内存数据 --- （调用 write 函数） ---> 操作空间内核缓冲区 --- （sync） ---> 磁盘。
>
> 内核缓冲区中的数据超过一定大小或者持续一定时间后，才会真正的写入到磁盘中。
>
> 为了保证数据的安全性，系统提供 fsync 和 fdatasync 函数，允许用户决定同步的时机。

显然，同步才能真正的持久化数据，但是同步频率过高又会影响效率。

Redis 允许用户在安全性和效率上进行取舍，通过配置服务器参数 *appendfsync* 可以控制同步的时机：

| 选项       | 行为                                                         | 评价                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| *always*   | 写入 `aof_buf` 中的所有内容，并且同步到 AOF；                | 效率低，但是安全性最高。最多损失一个事件循环中所产生的命令数据。 |
| *everysec* | 写入 `aof_buf` 中的所有内容，若距离上次同步时间超过一秒钟，则同步到 AOF； | 效率够快，而且最多只是顺序一秒的数据。                       |
| *no*       | 写入 `aof_buf` 中的所有内容，但从不主动同步，同步时机由操作系统决定； | 写入速度最快，同步时间最长。                                 |

总之，AOF 持久化分为三步：追加（APPEND）- 写入（WRITE）- 同步（SYNC）。

当写入操作完成就会追加，而写入和同步则是一个时间事件，交由 `serverCron` 负责。

## 2.2 AOF 的载入与数据还原

Redis 只需要重放一遍 AOF 的命令，就能够还原数据了，具体是通过伪造一个客户端实现的。

1）创建一个不带网络连接的伪客户端 fake  client；

2）从 AOF 文件中读出一条命令；

3）交由伪客户端执行；

4）重复 2）和 3）直到所有写命令被处理完毕。

## 2.3 AOF 重写

* 为什么需要重写？

  AOF 会不断被追加，随着积累的写命令越来越多，AOF 的体积也就越来越大。重写就是为了减少 AOF 体积。

* 重写为什么能减少 AOF 体积？

  AOF 持久化是为了还原数据库的状态，因此重要的数据最后的状态。

  一个键值对可能有很多历史操作，但是最终的状态是确定的，AOF 重写就是舍弃中间命令，只记录最终状态。

* AOF 重写过程

  首先创建一个新的 AOF 文件，然后遍历服务器中的所有键值对，对于每个键值对，根据对象类型，将重写命令写入到新的 AOF 文件中。

  可见，重写过程只是依赖当前服务器中的数据，**完全不依赖旧的 AOF 文件**。

  > 重写命令是啥？
  >
  > 比如重写一个字符键，记录 `set key value` 就可以了。

## 2.4 AOF 后台重写 *BGREWRITEAOF*

前面的重写过程比较简略，这里补充一下细节。

1）子进程执行 AOF 文件重写。

​	我们希望在重写过程中，服务器还能够继续正常工作，因此服务器会 fork 出一个子进程执行后台重写。

​	为什么不用一个线程重写？子进程保存了服务器进程的所有数据副本，这样**不需要加锁也能保证数据的安全性**。

2）AOF 重写缓冲区。

​	在子进程执行重写期间，服务器进程还在不断的执行命令，如何保证父子进程数的一致性？

​	当服务器 fork  子进程重写时，会设置一个 AOF 重写缓冲区，子进程重写期间，父进程会同时将写操作记录到 AOF 缓冲区和重写缓冲区。当子进程重写结束时，会向父进程发一个信号，父进程再将 AOF 重写缓冲区中的数据写入到新的 AOF 文件中。

​	当新的 AOF 文件数据更新完毕时，会原子覆盖老的 AOF 文件。

## 2.5 重点总结

* AOF 通过保存服务器的**写命令请求**来记录服务器的数据库状态。
* 服务器载入并重新执行 AOF 文件中的命令就可以还原数据库状态。
* AOF 文件格式：以 Redis 命令请求协议的格式保存。
* 请求会先写入到 AOF 缓冲区，然后再定期写入和同步到 AOF。
* *appendfsync* 提供同步选项，供用户平衡数据安全性服务器性能。
* AOF 重写可以产生一个新的 AOF 文件，这个新的文件和原先的 AOF 文件保存的数据库状态是一致的，但是体积更小。
* AOF 重写不依赖现有的 AOF 文件，因为是通过读取数据库中的键值对实现的。

# 3 - Redis 持久化优缺点比较

[Redis  persistence](https://redis.io/topics/persistence Redis)

比较方面：

* 文件格式和大小；
* 数据恢复的快慢；
* 数据的”韧性“ durable；
* 对主服务性能影响；

## 3.1 RDB

优点：

* 是对某个时刻 Redis 数据非常袖珍（very compact）的呈现；
* 非常适合灾难恢复（disater recovery），可以拷贝 RDB 文件到其他服务器上；
* RDB 最大化 Redis 服务主进程的表现（复制时会 fork 出子进程）
* 重启时相比于 AOF，RDB 恢复数据的速度更快；
* RDB 支持 psync replication；

缺点：

* 意外宕机时，数据丢失会比 AOF 严重；
* 产生 RDB 文件需要 fork 出一个子进程，数据库如果很大可能会比较耗时。AOF 重写功能可以关闭，这样就不会影响主服务。（关闭 RDB ？ 这会加剧数据丢失）

## 3.2 AOF

优点：

* much  durable;
* 自动重写；
* 文本格式，易读；

缺点：

* 文件更大；
* fsync 选项会很大影响 AOF 性能；即使是秒级 fsync，对主服务性能影响也很大；